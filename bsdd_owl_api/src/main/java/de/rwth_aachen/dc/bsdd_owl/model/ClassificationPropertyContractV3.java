/*
 * bSDD API prototype
 * API to access the buildingSMART Data Dictionary
 *
 * OpenAPI spec version: v1
 * Contact: bsdd_support@buildingsmart.org
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package de.rwth_aachen.dc.bsdd_owl.model;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

import com.google.gson.annotations.SerializedName;

import io.swagger.v3.oas.annotations.media.Schema;
/**
 * ClassificationPropertyContractV3
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2021-09-21T11:35:32.475Z[GMT]")
public class ClassificationPropertyContractV3 {
  @SerializedName("name")
  private String name = null;

  @SerializedName("description")
  private String description = null;

  @SerializedName("dataType")
  private String dataType = null;

  @SerializedName("dimension")
  private String dimension = null;

  @SerializedName("dimensionLength")
  private Integer dimensionLength = null;

  @SerializedName("dimensionMass")
  private Integer dimensionMass = null;

  @SerializedName("dimensionTime")
  private Integer dimensionTime = null;

  @SerializedName("dimensionElectricCurrent")
  private Integer dimensionElectricCurrent = null;

  @SerializedName("dimensionThermodynamicTemperature")
  private Integer dimensionThermodynamicTemperature = null;

  @SerializedName("dimensionAmountOfSubstance")
  private Integer dimensionAmountOfSubstance = null;

  @SerializedName("dimensionLuminousIntensity")
  private Integer dimensionLuminousIntensity = null;

  @SerializedName("dynamicParameterPropertyCodes")
  private List<String> dynamicParameterPropertyCodes = null;

  @SerializedName("example")
  private String example = null;

  @SerializedName("isDynamic")
  private Boolean isDynamic = null;

  @SerializedName("isRequired")
  private Boolean isRequired = null;

  @SerializedName("isWritable")
  private Boolean isWritable = null;

  @SerializedName("maxExclusive")
  private Double maxExclusive = null;

  @SerializedName("maxInclusive")
  private Double maxInclusive = null;

  @SerializedName("minExclusive")
  private Double minExclusive = null;

  @SerializedName("minInclusive")
  private Double minInclusive = null;

  @SerializedName("pattern")
  private String pattern = null;

  @SerializedName("physicalQuantity")
  private String physicalQuantity = null;

  @SerializedName("possibleValues")
  private List<ClassificationPropertyValueContractV3> possibleValues = null;

  @SerializedName("predefinedValue")
  private String predefinedValue = null;

  @SerializedName("propertyCode")
  private String propertyCode = null;

  @SerializedName("propertyDomainName")
  private String propertyDomainName = null;

  @SerializedName("propertyNamespaceUri")
  private String propertyNamespaceUri = null;

  @SerializedName("propertySet")
  private String propertySet = null;

  @SerializedName("propertyStatus")
  private String propertyStatus = null;

  @SerializedName("propertyValueKind")
  private String propertyValueKind = null;

  @SerializedName("symbol")
  private String symbol = null;

  @SerializedName("units")
  private List<String> units = null;

  public ClassificationPropertyContractV3 name(String name) {
    this.name = name;
    return this;
  }

   /**
   * Name of the property
   * @return name
  **/
  @Schema(required = true, description = "Name of the property")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public ClassificationPropertyContractV3 description(String description) {
    this.description = description;
    return this;
  }

   /**
   * Plain language description of the property.  If at Property level no description has been given but a \&quot;Definition\&quot; is available, then \&quot;Definition\&quot; is returned as description
   * @return description
  **/
  @Schema(description = "Plain language description of the property.  If at Property level no description has been given but a \"Definition\" is available, then \"Definition\" is returned as description")
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }

  public ClassificationPropertyContractV3 dataType(String dataType) {
    this.dataType = dataType;
    return this;
  }

   /**
   * Format for expressing the value of the property
   * @return dataType
  **/
  @Schema(description = "Format for expressing the value of the property")
  public String getDataType() {
    return dataType;
  }

  public void setDataType(String dataType) {
    this.dataType = dataType;
  }

  public ClassificationPropertyContractV3 dimension(String dimension) {
    this.dimension = dimension;
    return this;
  }

   /**
   * Dimension of the physical quantity in format \&quot;L M T I Θ N J\&quot;, for example \&quot;-2 1 0 0 0 0 0\&quot;.  With    L   Length    M   Mass    T   Time    I   Electric current    Θ   Thermodynamic Temperature    N   Amount of substance    J   Luminous intensity
   * @return dimension
  **/
  @Schema(description = "Dimension of the physical quantity in format \"L M T I Θ N J\", for example \"-2 1 0 0 0 0 0\".  With    L   Length    M   Mass    T   Time    I   Electric current    Θ   Thermodynamic Temperature    N   Amount of substance    J   Luminous intensity")
  public String getDimension() {
    return dimension;
  }

  public void setDimension(String dimension) {
    this.dimension = dimension;
  }

  public ClassificationPropertyContractV3 dimensionLength(Integer dimensionLength) {
    this.dimensionLength = dimensionLength;
    return this;
  }

   /**
   * The Length value of the dimension
   * @return dimensionLength
  **/
  @Schema(description = "The Length value of the dimension")
  public Integer getDimensionLength() {
    return dimensionLength;
  }

  public void setDimensionLength(Integer dimensionLength) {
    this.dimensionLength = dimensionLength;
  }

  public ClassificationPropertyContractV3 dimensionMass(Integer dimensionMass) {
    this.dimensionMass = dimensionMass;
    return this;
  }

   /**
   * The Mass value of the dimension
   * @return dimensionMass
  **/
  @Schema(description = "The Mass value of the dimension")
  public Integer getDimensionMass() {
    return dimensionMass;
  }

  public void setDimensionMass(Integer dimensionMass) {
    this.dimensionMass = dimensionMass;
  }

  public ClassificationPropertyContractV3 dimensionTime(Integer dimensionTime) {
    this.dimensionTime = dimensionTime;
    return this;
  }

   /**
   * The Time value of the dimension
   * @return dimensionTime
  **/
  @Schema(description = "The Time value of the dimension")
  public Integer getDimensionTime() {
    return dimensionTime;
  }

  public void setDimensionTime(Integer dimensionTime) {
    this.dimensionTime = dimensionTime;
  }

  public ClassificationPropertyContractV3 dimensionElectricCurrent(Integer dimensionElectricCurrent) {
    this.dimensionElectricCurrent = dimensionElectricCurrent;
    return this;
  }

   /**
   * The Electric current value of the dimension
   * @return dimensionElectricCurrent
  **/
  @Schema(description = "The Electric current value of the dimension")
  public Integer getDimensionElectricCurrent() {
    return dimensionElectricCurrent;
  }

  public void setDimensionElectricCurrent(Integer dimensionElectricCurrent) {
    this.dimensionElectricCurrent = dimensionElectricCurrent;
  }

  public ClassificationPropertyContractV3 dimensionThermodynamicTemperature(Integer dimensionThermodynamicTemperature) {
    this.dimensionThermodynamicTemperature = dimensionThermodynamicTemperature;
    return this;
  }

   /**
   * The Thermodynamic temperature value of the dimension
   * @return dimensionThermodynamicTemperature
  **/
  @Schema(description = "The Thermodynamic temperature value of the dimension")
  public Integer getDimensionThermodynamicTemperature() {
    return dimensionThermodynamicTemperature;
  }

  public void setDimensionThermodynamicTemperature(Integer dimensionThermodynamicTemperature) {
    this.dimensionThermodynamicTemperature = dimensionThermodynamicTemperature;
  }

  public ClassificationPropertyContractV3 dimensionAmountOfSubstance(Integer dimensionAmountOfSubstance) {
    this.dimensionAmountOfSubstance = dimensionAmountOfSubstance;
    return this;
  }

   /**
   * The Amount of substance value of the dimension
   * @return dimensionAmountOfSubstance
  **/
  @Schema(description = "The Amount of substance value of the dimension")
  public Integer getDimensionAmountOfSubstance() {
    return dimensionAmountOfSubstance;
  }

  public void setDimensionAmountOfSubstance(Integer dimensionAmountOfSubstance) {
    this.dimensionAmountOfSubstance = dimensionAmountOfSubstance;
  }

  public ClassificationPropertyContractV3 dimensionLuminousIntensity(Integer dimensionLuminousIntensity) {
    this.dimensionLuminousIntensity = dimensionLuminousIntensity;
    return this;
  }

   /**
   * The Luminous intensity value of the dimension
   * @return dimensionLuminousIntensity
  **/
  @Schema(description = "The Luminous intensity value of the dimension")
  public Integer getDimensionLuminousIntensity() {
    return dimensionLuminousIntensity;
  }

  public void setDimensionLuminousIntensity(Integer dimensionLuminousIntensity) {
    this.dimensionLuminousIntensity = dimensionLuminousIntensity;
  }

  public ClassificationPropertyContractV3 dynamicParameterPropertyCodes(List<String> dynamicParameterPropertyCodes) {
    this.dynamicParameterPropertyCodes = dynamicParameterPropertyCodes;
    return this;
  }

  public ClassificationPropertyContractV3 addDynamicParameterPropertyCodesItem(String dynamicParameterPropertyCodesItem) {
    if (this.dynamicParameterPropertyCodes == null) {
      this.dynamicParameterPropertyCodes = new ArrayList<String>();
    }
    this.dynamicParameterPropertyCodes.add(dynamicParameterPropertyCodesItem);
    return this;
  }

   /**
   * List of codes of the properties which are parameters of the function for a dynamic property.  Only applicable for dynamic properties (IsDynamic)
   * @return dynamicParameterPropertyCodes
  **/
  @Schema(description = "List of codes of the properties which are parameters of the function for a dynamic property.  Only applicable for dynamic properties (IsDynamic)")
  public List<String> getDynamicParameterPropertyCodes() {
    return dynamicParameterPropertyCodes;
  }

  public void setDynamicParameterPropertyCodes(List<String> dynamicParameterPropertyCodes) {
    this.dynamicParameterPropertyCodes = dynamicParameterPropertyCodes;
  }

  public ClassificationPropertyContractV3 example(String example) {
    this.example = example;
    return this;
  }

   /**
   * Illustrate possible use or values of the Property
   * @return example
  **/
  @Schema(description = "Illustrate possible use or values of the Property")
  public String getExample() {
    return example;
  }

  public void setExample(String example) {
    this.example = example;
  }

  public ClassificationPropertyContractV3 isDynamic(Boolean isDynamic) {
    this.isDynamic = isDynamic;
    return this;
  }

   /**
   * True if the value of this property is dependent on other properties (as provided in DynamicParameterPropertyCodes)
   * @return isDynamic
  **/
  @Schema(description = "True if the value of this property is dependent on other properties (as provided in DynamicParameterPropertyCodes)")
  public Boolean isIsDynamic() {
    return isDynamic;
  }

  public void setIsDynamic(Boolean isDynamic) {
    this.isDynamic = isDynamic;
  }

  public ClassificationPropertyContractV3 isRequired(Boolean isRequired) {
    this.isRequired = isRequired;
    return this;
  }

   /**
   * Indicates if this property is required for the classification
   * @return isRequired
  **/
  @Schema(description = "Indicates if this property is required for the classification")
  public Boolean isIsRequired() {
    return isRequired;
  }

  public void setIsRequired(Boolean isRequired) {
    this.isRequired = isRequired;
  }

  public ClassificationPropertyContractV3 isWritable(Boolean isWritable) {
    this.isWritable = isWritable;
    return this;
  }

   /**
   * Indicates if the value of the property can be changed by the user
   * @return isWritable
  **/
  @Schema(description = "Indicates if the value of the property can be changed by the user")
  public Boolean isIsWritable() {
    return isWritable;
  }

  public void setIsWritable(Boolean isWritable) {
    this.isWritable = isWritable;
  }

  public ClassificationPropertyContractV3 maxExclusive(Double maxExclusive) {
    this.maxExclusive = maxExclusive;
    return this;
  }

   /**
   * Maximum value of the property, exclusive  This value does not need to be the same as the MaxExclusive in the Property contract  because this value can be overruled at Classification-Property level to define a more strict value.
   * @return maxExclusive
  **/
  @Schema(description = "Maximum value of the property, exclusive  This value does not need to be the same as the MaxExclusive in the Property contract  because this value can be overruled at Classification-Property level to define a more strict value.")
  public Double getMaxExclusive() {
    return maxExclusive;
  }

  public void setMaxExclusive(Double maxExclusive) {
    this.maxExclusive = maxExclusive;
  }

  public ClassificationPropertyContractV3 maxInclusive(Double maxInclusive) {
    this.maxInclusive = maxInclusive;
    return this;
  }

   /**
   * Maximum value of the property, inclusive  This value does not need to be the same as the MaxInclusive in the Property contract  because this value can be overruled at Classification-Property level to define a more strict value.
   * @return maxInclusive
  **/
  @Schema(description = "Maximum value of the property, inclusive  This value does not need to be the same as the MaxInclusive in the Property contract  because this value can be overruled at Classification-Property level to define a more strict value.")
  public Double getMaxInclusive() {
    return maxInclusive;
  }

  public void setMaxInclusive(Double maxInclusive) {
    this.maxInclusive = maxInclusive;
  }

  public ClassificationPropertyContractV3 minExclusive(Double minExclusive) {
    this.minExclusive = minExclusive;
    return this;
  }

   /**
   * Minimum value of the property, exclusive  This value does not need to be the same as the MinExclusive in the Property contract  because this value can be overruled at Classification-Property level to define a more strict value.
   * @return minExclusive
  **/
  @Schema(description = "Minimum value of the property, exclusive  This value does not need to be the same as the MinExclusive in the Property contract  because this value can be overruled at Classification-Property level to define a more strict value.")
  public Double getMinExclusive() {
    return minExclusive;
  }

  public void setMinExclusive(Double minExclusive) {
    this.minExclusive = minExclusive;
  }

  public ClassificationPropertyContractV3 minInclusive(Double minInclusive) {
    this.minInclusive = minInclusive;
    return this;
  }

   /**
   * Minimum value of the property, inclusive  This value does not need to be the same as the MinInclusive in the Property contract  because this value can be overruled at Classification-Property level to define a more strict value.
   * @return minInclusive
  **/
  @Schema(description = "Minimum value of the property, inclusive  This value does not need to be the same as the MinInclusive in the Property contract  because this value can be overruled at Classification-Property level to define a more strict value.")
  public Double getMinInclusive() {
    return minInclusive;
  }

  public void setMinInclusive(Double minInclusive) {
    this.minInclusive = minInclusive;
  }

  public ClassificationPropertyContractV3 pattern(String pattern) {
    this.pattern = pattern;
    return this;
  }

   /**
   * An XML Schema Regular expression for the property value.  See for explanation: https://www.regular-expressions.info/xml.html.  This value does not need to be the same as the Pattern in the Property contract  because this value can be overruled at Classification-Property level to define a more strict value.
   * @return pattern
  **/
  @Schema(description = "An XML Schema Regular expression for the property value.  See for explanation: https://www.regular-expressions.info/xml.html.  This value does not need to be the same as the Pattern in the Property contract  because this value can be overruled at Classification-Property level to define a more strict value.")
  public String getPattern() {
    return pattern;
  }

  public void setPattern(String pattern) {
    this.pattern = pattern;
  }

  public ClassificationPropertyContractV3 physicalQuantity(String physicalQuantity) {
    this.physicalQuantity = physicalQuantity;
    return this;
  }

   /**
   * The quantity in plain text
   * @return physicalQuantity
  **/
  @Schema(description = "The quantity in plain text")
  public String getPhysicalQuantity() {
    return physicalQuantity;
  }

  public void setPhysicalQuantity(String physicalQuantity) {
    this.physicalQuantity = physicalQuantity;
  }

  public ClassificationPropertyContractV3 possibleValues(List<ClassificationPropertyValueContractV3> possibleValues) {
    this.possibleValues = possibleValues;
    return this;
  }

  public ClassificationPropertyContractV3 addPossibleValuesItem(ClassificationPropertyValueContractV3 possibleValuesItem) {
    if (this.possibleValues == null) {
      this.possibleValues = new ArrayList<ClassificationPropertyValueContractV3>();
    }
    this.possibleValues.add(possibleValuesItem);
    return this;
  }

   /**
   * List of possible values  This list does not need to be the same as the list of PossibleValues in the Property contract  because this list can be overruled at Classification-Property level to define a more strict list.
   * @return possibleValues
  **/
  @Schema(description = "List of possible values  This list does not need to be the same as the list of PossibleValues in the Property contract  because this list can be overruled at Classification-Property level to define a more strict list.")
  public List<ClassificationPropertyValueContractV3> getPossibleValues() {
    return possibleValues;
  }

  public void setPossibleValues(List<ClassificationPropertyValueContractV3> possibleValues) {
    this.possibleValues = possibleValues;
  }

  public ClassificationPropertyContractV3 predefinedValue(String predefinedValue) {
    this.predefinedValue = predefinedValue;
    return this;
  }

   /**
   * Predefined value: if the classification can have only one value for this property, this is it
   * @return predefinedValue
  **/
  @Schema(description = "Predefined value: if the classification can have only one value for this property, this is it")
  public String getPredefinedValue() {
    return predefinedValue;
  }

  public void setPredefinedValue(String predefinedValue) {
    this.predefinedValue = predefinedValue;
  }

  public ClassificationPropertyContractV3 propertyCode(String propertyCode) {
    this.propertyCode = propertyCode;
    return this;
  }

   /**
   * Code of the property, only applicable if property is of the same domain as the classification.
   * @return propertyCode
  **/
  @Schema(description = "Code of the property, only applicable if property is of the same domain as the classification.")
  public String getPropertyCode() {
    return propertyCode;
  }

  public void setPropertyCode(String propertyCode) {
    this.propertyCode = propertyCode;
  }

  public ClassificationPropertyContractV3 propertyDomainName(String propertyDomainName) {
    this.propertyDomainName = propertyDomainName;
    return this;
  }

   /**
   * Name of the Domain this property belongs to
   * @return propertyDomainName
  **/
  @Schema(description = "Name of the Domain this property belongs to")
  public String getPropertyDomainName() {
    return propertyDomainName;
  }

  public void setPropertyDomainName(String propertyDomainName) {
    this.propertyDomainName = propertyDomainName;
  }

  public ClassificationPropertyContractV3 propertyNamespaceUri(String propertyNamespaceUri) {
    this.propertyNamespaceUri = propertyNamespaceUri;
    return this;
  }

   /**
   * Unique identification of the property
   * @return propertyNamespaceUri
  **/
  @Schema(description = "Unique identification of the property")
  public String getPropertyNamespaceUri() {
    return propertyNamespaceUri;
  }

  public void setPropertyNamespaceUri(String propertyNamespaceUri) {
    this.propertyNamespaceUri = propertyNamespaceUri;
  }

  public ClassificationPropertyContractV3 propertySet(String propertySet) {
    this.propertySet = propertySet;
    return this;
  }

   /**
   * Name of the Property Set
   * @return propertySet
  **/
  @Schema(description = "Name of the Property Set")
  public String getPropertySet() {
    return propertySet;
  }

  public void setPropertySet(String propertySet) {
    this.propertySet = propertySet;
  }

  public ClassificationPropertyContractV3 propertyStatus(String propertyStatus) {
    this.propertyStatus = propertyStatus;
    return this;
  }

   /**
   * Status of the property: Preview, Active or Inactive
   * @return propertyStatus
  **/
  @Schema(description = "Status of the property: Preview, Active or Inactive")
  public String getPropertyStatus() {
    return propertyStatus;
  }

  public void setPropertyStatus(String propertyStatus) {
    this.propertyStatus = propertyStatus;
  }

  public ClassificationPropertyContractV3 propertyValueKind(String propertyValueKind) {
    this.propertyValueKind = propertyValueKind;
    return this;
  }

   /**
   * Indicates kind of value: Single, Range (2 values expected), List (multiple values expected), Complex (use in combination with \&quot;ConnectedProperties\&quot;), ComplexList
   * @return propertyValueKind
  **/
  @Schema(description = "Indicates kind of value: Single, Range (2 values expected), List (multiple values expected), Complex (use in combination with \"ConnectedProperties\"), ComplexList")
  public String getPropertyValueKind() {
    return propertyValueKind;
  }

  public void setPropertyValueKind(String propertyValueKind) {
    this.propertyValueKind = propertyValueKind;
  }

  public ClassificationPropertyContractV3 symbol(String symbol) {
    this.symbol = symbol;
    return this;
  }

   /**
   * Symbol of the property
   * @return symbol
  **/
  @Schema(description = "Symbol of the property")
  public String getSymbol() {
    return symbol;
  }

  public void setSymbol(String symbol) {
    this.symbol = symbol;
  }

  public ClassificationPropertyContractV3 units(List<String> units) {
    this.units = units;
    return this;
  }

  public ClassificationPropertyContractV3 addUnitsItem(String unitsItem) {
    if (this.units == null) {
      this.units = new ArrayList<String>();
    }
    this.units.add(unitsItem);
    return this;
  }

   /**
   * List of units to select from
   * @return units
  **/
  @Schema(description = "List of units to select from")
  public List<String> getUnits() {
    return units;
  }

  public void setUnits(List<String> units) {
    this.units = units;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ClassificationPropertyContractV3 classificationPropertyContractV3 = (ClassificationPropertyContractV3) o;
    return Objects.equals(this.name, classificationPropertyContractV3.name) &&
        Objects.equals(this.description, classificationPropertyContractV3.description) &&
        Objects.equals(this.dataType, classificationPropertyContractV3.dataType) &&
        Objects.equals(this.dimension, classificationPropertyContractV3.dimension) &&
        Objects.equals(this.dimensionLength, classificationPropertyContractV3.dimensionLength) &&
        Objects.equals(this.dimensionMass, classificationPropertyContractV3.dimensionMass) &&
        Objects.equals(this.dimensionTime, classificationPropertyContractV3.dimensionTime) &&
        Objects.equals(this.dimensionElectricCurrent, classificationPropertyContractV3.dimensionElectricCurrent) &&
        Objects.equals(this.dimensionThermodynamicTemperature, classificationPropertyContractV3.dimensionThermodynamicTemperature) &&
        Objects.equals(this.dimensionAmountOfSubstance, classificationPropertyContractV3.dimensionAmountOfSubstance) &&
        Objects.equals(this.dimensionLuminousIntensity, classificationPropertyContractV3.dimensionLuminousIntensity) &&
        Objects.equals(this.dynamicParameterPropertyCodes, classificationPropertyContractV3.dynamicParameterPropertyCodes) &&
        Objects.equals(this.example, classificationPropertyContractV3.example) &&
        Objects.equals(this.isDynamic, classificationPropertyContractV3.isDynamic) &&
        Objects.equals(this.isRequired, classificationPropertyContractV3.isRequired) &&
        Objects.equals(this.isWritable, classificationPropertyContractV3.isWritable) &&
        Objects.equals(this.maxExclusive, classificationPropertyContractV3.maxExclusive) &&
        Objects.equals(this.maxInclusive, classificationPropertyContractV3.maxInclusive) &&
        Objects.equals(this.minExclusive, classificationPropertyContractV3.minExclusive) &&
        Objects.equals(this.minInclusive, classificationPropertyContractV3.minInclusive) &&
        Objects.equals(this.pattern, classificationPropertyContractV3.pattern) &&
        Objects.equals(this.physicalQuantity, classificationPropertyContractV3.physicalQuantity) &&
        Objects.equals(this.possibleValues, classificationPropertyContractV3.possibleValues) &&
        Objects.equals(this.predefinedValue, classificationPropertyContractV3.predefinedValue) &&
        Objects.equals(this.propertyCode, classificationPropertyContractV3.propertyCode) &&
        Objects.equals(this.propertyDomainName, classificationPropertyContractV3.propertyDomainName) &&
        Objects.equals(this.propertyNamespaceUri, classificationPropertyContractV3.propertyNamespaceUri) &&
        Objects.equals(this.propertySet, classificationPropertyContractV3.propertySet) &&
        Objects.equals(this.propertyStatus, classificationPropertyContractV3.propertyStatus) &&
        Objects.equals(this.propertyValueKind, classificationPropertyContractV3.propertyValueKind) &&
        Objects.equals(this.symbol, classificationPropertyContractV3.symbol) &&
        Objects.equals(this.units, classificationPropertyContractV3.units);
  }

  @Override
  public int hashCode() {
    return Objects.hash(name, description, dataType, dimension, dimensionLength, dimensionMass, dimensionTime, dimensionElectricCurrent, dimensionThermodynamicTemperature, dimensionAmountOfSubstance, dimensionLuminousIntensity, dynamicParameterPropertyCodes, example, isDynamic, isRequired, isWritable, maxExclusive, maxInclusive, minExclusive, minInclusive, pattern, physicalQuantity, possibleValues, predefinedValue, propertyCode, propertyDomainName, propertyNamespaceUri, propertySet, propertyStatus, propertyValueKind, symbol, units);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ClassificationPropertyContractV3 {\n");
    
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    dataType: ").append(toIndentedString(dataType)).append("\n");
    sb.append("    dimension: ").append(toIndentedString(dimension)).append("\n");
    sb.append("    dimensionLength: ").append(toIndentedString(dimensionLength)).append("\n");
    sb.append("    dimensionMass: ").append(toIndentedString(dimensionMass)).append("\n");
    sb.append("    dimensionTime: ").append(toIndentedString(dimensionTime)).append("\n");
    sb.append("    dimensionElectricCurrent: ").append(toIndentedString(dimensionElectricCurrent)).append("\n");
    sb.append("    dimensionThermodynamicTemperature: ").append(toIndentedString(dimensionThermodynamicTemperature)).append("\n");
    sb.append("    dimensionAmountOfSubstance: ").append(toIndentedString(dimensionAmountOfSubstance)).append("\n");
    sb.append("    dimensionLuminousIntensity: ").append(toIndentedString(dimensionLuminousIntensity)).append("\n");
    sb.append("    dynamicParameterPropertyCodes: ").append(toIndentedString(dynamicParameterPropertyCodes)).append("\n");
    sb.append("    example: ").append(toIndentedString(example)).append("\n");
    sb.append("    isDynamic: ").append(toIndentedString(isDynamic)).append("\n");
    sb.append("    isRequired: ").append(toIndentedString(isRequired)).append("\n");
    sb.append("    isWritable: ").append(toIndentedString(isWritable)).append("\n");
    sb.append("    maxExclusive: ").append(toIndentedString(maxExclusive)).append("\n");
    sb.append("    maxInclusive: ").append(toIndentedString(maxInclusive)).append("\n");
    sb.append("    minExclusive: ").append(toIndentedString(minExclusive)).append("\n");
    sb.append("    minInclusive: ").append(toIndentedString(minInclusive)).append("\n");
    sb.append("    pattern: ").append(toIndentedString(pattern)).append("\n");
    sb.append("    physicalQuantity: ").append(toIndentedString(physicalQuantity)).append("\n");
    sb.append("    possibleValues: ").append(toIndentedString(possibleValues)).append("\n");
    sb.append("    predefinedValue: ").append(toIndentedString(predefinedValue)).append("\n");
    sb.append("    propertyCode: ").append(toIndentedString(propertyCode)).append("\n");
    sb.append("    propertyDomainName: ").append(toIndentedString(propertyDomainName)).append("\n");
    sb.append("    propertyNamespaceUri: ").append(toIndentedString(propertyNamespaceUri)).append("\n");
    sb.append("    propertySet: ").append(toIndentedString(propertySet)).append("\n");
    sb.append("    propertyStatus: ").append(toIndentedString(propertyStatus)).append("\n");
    sb.append("    propertyValueKind: ").append(toIndentedString(propertyValueKind)).append("\n");
    sb.append("    symbol: ").append(toIndentedString(symbol)).append("\n");
    sb.append("    units: ").append(toIndentedString(units)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
